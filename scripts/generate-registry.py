#!/usr/bin/env python3
"""Scan workspace and generate dt-plugins.yaml.

This script scans the workspace for Python and Node plugins and generates
the plugin registry file used by dt-core to discover Node plugins.

Python plugins are discovered via entry points at runtime, but are also
listed in the registry for documentation purposes.

Node plugins are discovered by looking for dt-plugin.yaml marker files.
"""

from pathlib import Path

try:
    import tomllib
except ImportError:
    import tomli as tomllib  # type: ignore

import yaml

REPO_ROOT = Path(__file__).parent.parent
DOMAINS = ["common", "nab", "tinybots"]


def find_python_plugins() -> dict:
    """Find Python plugins by scanning for entry points in pyproject.toml."""
    plugins = {}

    for domain in DOMAINS:
        cli_dir = REPO_ROOT / domain / "cli"
        if not cli_dir.exists():
            continue

        for pkg_dir in cli_dir.iterdir():
            if not pkg_dir.is_dir() or pkg_dir.name == "dt-core":
                continue

            pyproject = pkg_dir / "pyproject.toml"
            if not pyproject.exists():
                continue

            try:
                content = pyproject.read_text()
                data = tomllib.loads(content)

                # Check if it has dt.plugins entry point
                entry_points = data.get("project", {}).get("entry-points", {})
                if "dt.plugins" in entry_points:
                    for name, entry in entry_points["dt.plugins"].items():
                        plugins[name] = {
                            "type": "python",
                            "entry": entry,
                            "path": str(pkg_dir.relative_to(REPO_ROOT)),
                        }
            except Exception as e:
                print(f"Warning: Failed to parse {pyproject}: {e}")

    return plugins


def find_node_plugins() -> dict:
    """Find Node plugins by scanning for dt-plugin.yaml markers."""
    plugins = {}

    for marker in REPO_ROOT.rglob("dt-plugin.yaml"):
        pkg_dir = marker.parent

        try:
            with open(marker) as f:
                config = yaml.safe_load(f)

            if not config:
                continue

            name = config.get("name")
            if not name:
                print(f"Warning: dt-plugin.yaml at {marker} missing 'name' field")
                continue

            bin_path = config.get("bin")
            if not bin_path:
                print(f"Warning: dt-plugin.yaml at {marker} missing 'bin' field")
                continue

            plugins[name] = {
                "type": "node",
                "bin": str((pkg_dir / bin_path).relative_to(REPO_ROOT)),
                "path": str(pkg_dir.relative_to(REPO_ROOT)),
                "description": config.get("description", ""),
            }
        except Exception as e:
            print(f"Warning: Failed to parse {marker}: {e}")

    return plugins


def main():
    print("Scanning for plugins...")

    python_plugins = find_python_plugins()
    print(f"  Found {len(python_plugins)} Python plugin(s)")

    node_plugins = find_node_plugins()
    print(f"  Found {len(node_plugins)} Node plugin(s)")

    plugins = {}
    plugins.update(python_plugins)
    plugins.update(node_plugins)

    output = REPO_ROOT / "dt-plugins.yaml"

    # Build content with header comment
    header = "# Auto-generated by scripts/generate-registry.py\n"
    header += "# Do not edit manually. Run: python scripts/generate-registry.py\n\n"

    content = yaml.dump({"plugins": plugins}, default_flow_style=False, sort_keys=False)

    output.write_text(header + content)
    print(f"\nGenerated {output} with {len(plugins)} plugin(s)")


if __name__ == "__main__":
    main()
